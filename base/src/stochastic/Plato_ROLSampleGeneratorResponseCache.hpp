#pragma once

#include "Plato_StochasticSample.hpp"
#include "Plato_SampleResponseCache.hpp"

#include "ROL_SampleGenerator.hpp"

#include <optional>

namespace Plato
{

/// @brief Caches results of evaluating a function with samples produced by a ROL::SampleGenerator
///
/// The purpose of this class is to help parallelize the Stochastic ROL interface with Plato.
/// This is accomplished by caching results of all samples so that when samples are requested
/// individually, they can be retrieved from the cache. The function passed to this class on
/// construction should implement parallel evaluation of a set of samples.
///
/// @tparam StoredType The return type of the function to evaluate
template<typename StoredType>
class ROLSampleGeneratorResponseCache
{
public:
    /// @param aFunction Function to evaluate a vector of samples and return a vector of results. The function must
    ///  be callable with a DistributedVectorROL and a vector of Sample and return a vector of StoredType.
    template<typename Function>
    ROLSampleGeneratorResponseCache(const Function& aFunction, ROL::Ptr<ROL::SampleGenerator<double>> aSampleGenerator);

    /// @brief Retrieve a result stored in the cache.
    /// @pre @a aSample must be a sample generated by the SampleGenerator passed on construction.
    /// @note If @a aControl or @a aSample is not in the cache, all samples generated by the SampleGenerator passed on
    ///  construction will be reevaluated.
    /// @warning Not thread safe.
    [[nodiscard]]
    const StoredType& operator()(const Plato::DistributedVectorROL<double>& aControl, const Plato::Sample& aSample) const;

    /// @brief Checks if @a aControl was used to generate the current set of cached values.
    [[nodiscard]]
    bool exists(const Plato::DistributedVectorROL<double>& aControl) const;

    /// @brief Checks if @a aControl was used to generate the current set of cached values and @a aSample is in the cache.
    /// @note This is mostly useful for testing.
    [[nodiscard]]
    bool exists(const Plato::DistributedVectorROL<double>& aControl, const Plato::Sample& aSample) const;

    /// @return All samples generated by the SampleGenerator passed on construction.
    [[nodiscard]]
    std::vector<Plato::Sample> allSamples() const;

private:
    void resetCacheWithControl(const Plato::DistributedVectorROL<double>& aControl) const;

private:
    using FunctionSignature = std::vector<StoredType>(const Plato::DistributedVectorROL<double>&, const std::vector<Plato::Sample>&);
    std::function<FunctionSignature> mFunction;
    ROL::Ptr<ROL::SampleGenerator<double>> mSampleGenerator;

    mutable std::optional<Plato::SampleResponseCache<StoredType>> mCache;
    mutable std::size_t mControlHash = 0;
};

namespace detail
{
template<typename ScalarType>
std::size_t rol_vector_hash(const Plato::DistributedVectorROL<ScalarType>& aVector)
{
    return Plato::vector_hash(aVector.vector());
}
}

template<typename StoredType>
template<typename Function>
ROLSampleGeneratorResponseCache<StoredType>::ROLSampleGeneratorResponseCache(
    const Function& aFunction, 
    ROL::Ptr<ROL::SampleGenerator<double>> aSampleGenerator) : 
    mFunction(aFunction),
    mSampleGenerator(std::move(aSampleGenerator))
{
    static_assert(std::is_invocable_r_v<
                    std::vector<StoredType>, 
                    Function, 
                    const Plato::DistributedVectorROL<double>&, 
                    const std::vector<Plato::Sample>&>, 
        "Function must be callable with Plato::DistributedVectorROL<double>"
        " and std::vector<Plato::Sample> and return std::vector<StoredType>");
}

template<typename StoredType>
const StoredType& ROLSampleGeneratorResponseCache<StoredType>::operator()(
    const Plato::DistributedVectorROL<double>& aControl, const Plato::Sample& aSample) const
{
    if(!exists(aControl))
    {
        resetCacheWithControl(aControl);
    }
    auto tResponse = mCache->get(aSample);
    assert(tResponse);
    return tResponse.value();
}

template<typename StoredType>
bool ROLSampleGeneratorResponseCache<StoredType>::exists(const Plato::DistributedVectorROL<double>& aControl) const
{
    return mCache.has_value() && 
        Plato::detail::rol_vector_hash(aControl) == mControlHash;
}

template<typename StoredType>
bool ROLSampleGeneratorResponseCache<StoredType>::exists(
    const Plato::DistributedVectorROL<double>& aControl, const Plato::Sample& aSample) const
{
    return exists(aControl) && mCache->get(aSample).has_value();
}

template<typename StoredType>
std::vector<Plato::Sample> ROLSampleGeneratorResponseCache<StoredType>::allSamples() const
{
    std::vector<Plato::Sample> tSamples;
    for(int i = 0; i < mSampleGenerator->numMySamples(); ++i)
    {
        tSamples.push_back(Plato::Sample{mSampleGenerator->getMyPoint(i)});
    }
    return tSamples;
}

template<typename StoredType>
void ROLSampleGeneratorResponseCache<StoredType>::resetCacheWithControl(const Plato::DistributedVectorROL<double>& aControl) const
{
    mCache.emplace();
    std::vector<Plato::Sample> tSamples = allSamples();
    std::vector<StoredType> tResults = mFunction(aControl, tSamples);
    mCache->insert(std::move(tSamples), std::move(tResults));
    mControlHash = Plato::detail::rol_vector_hash(aControl);
}

}
